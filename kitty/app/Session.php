<?namespace kitty\app;use kitty\web\arr;/*  * Общий класс сессий  **/  /*CREATE TABLE IF NOT EXISTS `session_storage` (`sid` char(62) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,`expires` int(18) NOT NULL,`session_data` varchar(8000) NOT NULL,PRIMARY KEY (`sid`),KEY `expires` (`expires`)) ENGINE=MEMORY DEFAULT CHARSET=utf8; */     class session {		private static $instance = null;	private static $handle_driver = null; 		private function __construct() {}    private function __clone() {}				public static function get($key, $default =null ){		return arr::get($_SESSION,$key,$default);	}		public static function set($key, $value ){		arr::set($_SESSION[$key],$value);	}		public static function instance($reinit = false){            if(!self::$instance || true == $reinit) {								if (true == is_null(self::$instance)){					self::$instance = new session();				}				$conf   = config::get('session');				$driver = strtolower($conf['driver']);																switch($driver):					case 'file':  break;					case 'memcache':				    case 'bd': $self_handle_driver = new session_driver_bd(); break;				endswitch;			    					if(isset($self_handle_driver)){						self::$handle_driver = $self_handle_driver;						session_set_save_handler(							array($self_handle_driver, "open"),							array($self_handle_driver, "close"),							array($self_handle_driver, "read"),							array($self_handle_driver, "write"),							array($self_handle_driver, "destroy"),							array($self_handle_driver, "gc")						);						register_shutdown_function('session_write_close');											}					if(isset($_COOKIE[session_name()])){						session_start();					}			}            return self::$instance;          }				public static function online($t=120){			self::instance();			return self::$handle_driver->online($t);		}				// преобразуем session_data в удобный для нас массив		// получение текушей сесии данный session_encode();		public static function decode($data = '') {			(array)$vars=preg_split('/([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff^|]*)\|/s', $data,-1,PREG_SPLIT_NO_EMPTY | PREG_SPLIT_DELIM_CAPTURE);			for($i=0; $vars[$i]; $i++){				$result[$vars[$i++]] = unserialize($vars[$i]);				if(!isset($vars[$i+1])) break;			}			return $result;		}				/*		 * Установка $sid или получаем текущий		 * @param  $sid  установка SESSION_ID 		 		 **/ 		public static function sid($sid = ''){			return session_id($sid);			}				// Получить массив сесси указоного sid либо текущию сессию		public static function getData($sid = null){			self::instance();			if(is_null($sid)) $sid = self::sid();						(string) $raw = self::$handle_driver->getData($sid);			return self::decode($raw);		}	}/* драйвер сессий на mysql  **/class session_driver_bd {		// open сессия	public function open($path, $name){		$pdo = bd::make();			return true;	}	// сессия	public function close(){		$time_left = ini_get('session.gc_maxlifetime') > 0 ? ini_get('session.gc_maxlifetime') :  1440;		return self::gc($time_left , session::sid() );	}		// Читаем данные session	public function read($sid)	{		$pdo = bd::make();			try {			$sql = 'SELECT * FROM  session_storage WHERE `sid`=:sid';			(array) $data = $pdo->prepare($sql)->execute(array(':sid' => $sid))->fetchAll(PDO::FETCH_ASSOC);			if(count($data) > 0){				 $sql = 'UPDATE `session_storage` SET expires=:upp_time WHERE sid=:sid';				 $pdo->prepare($sql)->execute(array(':sid' => $sid, ':upp_time'=> time() ));				return $data[0]['session_data'];			}else{				 $sql = 'INSERT INTO `session_storage` SET sid=:sid, expires=:upp_time';				 $pdo->prepare($sql)->execute(array(':sid' => $sid, ':upp_time'=> time() ));							}		}catch(PDOException $e){					}		return '';	}		// Пишем данные session	public function write($sid , $data){		$pdo = bd::make();		$sql ='UPDATE `session_storage` SET expires=:upp_time , `session_data`=:data WHERE sid=:sid';		$pdo->prepare($sql)->execute(array(':sid' => $sid, ':upp_time'=> time() , ':data'=> $data ));		return true;	}		// дестрой сессии	public function destroy($sid){		$pdo = bd::make();		$sql = 'DELETE FROM `session_storage` WHERE `sid`=:sid';		$pdo->prepare($sql)->execute(array(':sid' => $sid));		return true;	}		// Сборщик мусора	public function gc($max_time_live , $sid = '' ){		$pdo = bd::make();		$sql = 'DELETE FROM `session_storage` WHERE expires + :maxlivesession < :upp_time :sid';			if(!empty($sid)){			$sid = " AND sid='{$sid}'";		} 		$pdo->prepare($sql)->execute(array(':maxlivesession' => $max_time_live, ':upp_time'=> time() , ':sid'=> $sid ) );			    return true;	}		// статистика сессий	public function online($time_left = 150){		$pdo = bd::make();		$time_left = time() - $time_left;		$sql = "select count(sid) as count from session_storage WHERE expires > :time_left";		(array)$data =  $pdo->prepare($sql)->execute(array(':time_left' => $time_left) )->fetch(PDO::FETCH_ASSOC);		return $data['count'];			}	// Получить сессионые данные указоной сессии	public function getData($sid){		$pdo = bd::make();		$sql = 'SELECT * FROM  session_storage WHERE `sid`=:sid';		(array) $data  = $pdo->prepare($sql)->execute(array(':sid' => $sid))->fetchAll(PDO::FETCH_ASSOC);		return $data[0]['session_data'];	}	}/* драйвер сессий на memcached **/class session_driver_memcached {		public function open($path, $name){		return true;	}		public function close(){		$time_left = ini_get('session.gc_maxlifetime') > 0 ? ini_get('session.gc_maxlifetime') :  1440;		return self::gc($time_left , session::sid() );	}}/* драйвер сессий на xcache **/class session_driver_xcache {	// open	public static function open($path, $name){		return true;	}	// close	public static function close(){		$time_left = ini_get('session.gc_maxlifetime') > 0 ? ini_get('session.gc_maxlifetime') :  1440;		return self::gc($time_left , session::sid() );	}		public static function read($sid){            return (string)xcache_get("session/{$sid}");    }		public static function write($sid, $data){		$time_left = ini_get('session.gc_maxlifetime') > 0 ? ini_get('session.gc_maxlifetime') :  1440;        return xcache_set("session/{$sid}", $data, $time_left );    }		public static function destroy($sid){        xcache_unset("session/{$sid}");        return true;    }		public static function gc($max_lifetime , $sid=''){        return true;    }		public function getData($sid){		return self::read("session/{$sid}");	}		public function online($time_left = 150){ return 0;}		}class session_driver_file {}?>